# 1. 예외(에러, 오류)
1. 프로그램이 동작하다가 어떠한 원인에 의해서 강제 종료 되는 경우가 있다. 이런 경우를 초래하는 원인을 에러, 오류, 예외라고 부른다.
- 컴파일 에러: 컴파일 중 발생한 에러
- 런타임 에러: 프로그램 실행 중 발생한 에러
- 논리적 에러: 실행은 되지만 예상대로 동작하지 않는 에러

# 2. 예외 처리
1. 에러가 발생해 프로그램이 강제 종료되는 상황을 방지하거나 에러가 발생하지 않도록 로그로 남겨서 소스코드를 수정하는 행위이다.
2. Checked Exception: 컴파일러가 예외 처리를 강제시키는 예외로써 무조건 예외 처리 코드를 작성해야 한다.  
e.g. IOException, ClassNotFoundException, ...  
throws, try~catch 블록으로 예외 처리
3. Unchecked Exception: 컴파일러가 예외 처리를 강제하지 않는 예외이며 예외 처리 코드를 작성하지 않아도 된다.  
e.g. NullPointerException, ArrayIndexOutOfBoundsException, ...

# 3. try~catch~finally 블록
1. try{} 블록 내의 소스코드를 실행하다가 예외가 발생하면 catch{} 블록으로 이동해서 예외 처리 코드를 실행하는 코드이다.
2. finally{} 블록은 예외가 발생하든 하지 않든 무조건 실행된다.
3. Exception의 getMessage(), printStackTrace()
- getMessage(): 발생한 예외 class 객체에 저장된 메시지를 전달한다.
- printStackTrace(): 예외 발생 시 호출된 메소드() 정보와 class 정보, 예외 메시지까지 모두 출력한다. 보안상 문제로 취약점 검사에 무조건 걸린다. println()이나 log 라이브러리로 대체해서 사용한다.
4. 예외 발생했을 때: try{} 블록 코드 실행 -> 코드 실행 중 예외 발생 시 catch{} 블록으로 이동 -> catch{} 블록에서 예외 처리 -> finally{} 블록 실행
5. 예외 발생하지 않았을 때: try{} 블록 코드 실행 -> finally{} 블록 실행
6. finally{} 블록의 작성 여부는 선택 사항이나 try{}~catch{} 블록은 반드시 작성해야 한다.

# 4. 예외 발생시키기
1. 예외class 변수명 = new 예외class(메시지); throw 변수명;

# 5. 메소드()에서 예외 선언(throws)
1. 메소드() 호출한 곳에 예외를 전달한다.
2. 리턴타입 메소드명(매개변수) throws 예외class {  

}

# 6. 예외 처리의 중요성
1. 예외 처리는 프로그램의 안정성을 보장해주는 코드이다. 습관적으로 예외 처리 코드를 작성해 예외가 발생하더라도 프로그램이 안정적으로 돌아갈 수 있도록 한다.
2. try{}~ catch{}~finally{} 분리되어 있기 때문에 코드 가독성이 높아진다. 블록별로 나눠져 있기 때문에 흐름을 파악하기 쉬워진다.