# 1. 다형성
1. 많은 형태를 가진다는 의미이다.
2. 자식class가 부모class를 상속 받으면 자식class의 형태를 가지면서 부모class의 형태도 지니게 된다.
- 부모class 형태의 변수에 자식class의 객체를 넣어서 사용하면 하나의 변수로 다양한 기능을 만들 수 있다.
- 오버라이딩을 통해 기능의 다양화가 이뤄진다. 부모class에 존재하는 메소드를 자식class에서 오버라이딩을 다양한 기능으로 만들어서 부모class 형태의 변수로 같은 메소드를 호출했을 때에 서로 다른 결과나 기능을 수행하게 된다.

# 2. 다형성의 장점
1. 유연성: 여러 객체를 하나의 변수로 처리할 수 있어서 유연하게 객체를 변경할 수 있다.
2. 확장성: 부모class를 상속받은 다양한 class를 새로 만들어도 같은 변수에 객체만 변경하면 되기 때문에 class를 추가하여 확장하기 유리하다.
3. 코드의 가독성: 부모class 타입의 변수 하나만 선언해서 사용하며 일관된 방식으로 메소드()를 호출하기 때문에 가독성을 높일 수 있다.
4. 코드의 재사용성: 변수 하나로 여러 개의 객체를 사용할 수 있어서 재사용성이 높아진다.
5. 유지보수성: class를 추가하거나 기능을 변경할 때에 수정해야 하는 부분이 다형성을 사용하지 않을 때보다 많이 줄어든다.

# 3. 다형성의 단점
1. 성능 저하: 다형성을 이용하면 객체의 타입을 찾아야 하므로 일반적인 메소드() 호출보다 느리게 동작할 수 있다. 8GB 이상 메모리 또는 64비트 OS 등으로 성능이 증가한 현 시점에서는 성능 저하가 일어나더라도 무시할 만한 수준이다.
2. 복잡성: class 간의 관계가 많아질수록 이해하기에 복잡해진다. 코드 분석도 어려워진다. 만들기 전에 class 구조와 설계를 수립하는 데에 주의를 기울여야 한다.
3. 오버라이딩 기능 오류: 다형성을 구현할 때에 오버라이딩을 잘못 사용하면 오작동할 때가 있다.
4. 코드의 가독성: 관계의 레벨이 깊어질수록 한번에 객체의 타입을 파악하기가 힘들어진다.

# 4. super 키워드
1. 자식class에서 부모class의 멤버변수 및 메소드()에 접근하거나 호출하기 위해서는 super 키워드를 사용해야 한다.
2. 부모class의 멤버변수 접근 방식
- 접근제어자가 protected 이상일 때(public, protected): super.변수명으로 접근 가능하다.
- 접근제어자가 default일 때:
    - 같은 패키지에 존재: super.변수명
    - 다른 패키지에 존재: getter/setter를 통해 접근 => super.getter/setter
- 접근제어자가 private일 때: super.getter/setter
3. 부모class의 메소드() 호출 방식
- public, protected: super.메소드명();
- default: 같은 패키지에 존재하지 않으면 호출 불가. 같은 패키지에 존재: super.메소드명();
- private: 메소드() 호출이 불가하다.
4. 부모class의 생성자 호출 방식
- super(), super(매개변수)로 기본생성자나 매개변수 있는 생성자를 호출할 수 있다.
- 자식 객체가 만들어질 때 부모class의 인스턴스가 먼저 생성되기 때문에 자식class의 생성자에서도 항상 처음으로 호출돼야 한다. 이후 남은 초기화를 처리한다.  
e.g. public 자식class() {  
    super(); => 항상 먼저 호출  
    나머지 작업  
}  

# 5. Java의 최상위 Class "Object"
1. 모든 class가 만들어질 때 Object를 상속받는다.
2. 모든 class는 Object에 구현되어 있는 메소드(toString(), notify(), notifyAll(), ...)를 사용할 수 있다.
3. 다형성의 측면에서 Object를 타입으로 지정하면 모든 class를 넣어서 사용할 수 있게 되며 엄청난 확장성을 획득하게 된다.  
e.g. Map<String, Object> => value의 타입을 Object로 정했기 때문에 value에는 모든 class가 들어갈 수 있다.