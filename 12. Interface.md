# 1. 인터페이스
1. 인터페이스는 추상class의 일종이다.
2. 추상class보다 추상화 레벨이 더 높다(더 깊게 추상화 된다).
3. 추상class 구성: 멤버변수, 일반메소드(), 추상메소드();  
인터페이스 구성: 멤버변수, 추상메소드()만 가지며 멤버변수는 반드시 final 키워드를 사용한 상수이다.
4. 인터페이스가 가질 수 있는 요소의 정의
- 변수는 무조건 public static final으로 시작해야 하나 생략 가능하다.
- 메소드() 역시 무조건 public abstract로 시작해야 하나 생략 가능하다. 1.8 이상부터는 static 메소드와 default 메소드가 사용 가능해졌다.
5. 인터페이스의 정의
- interface 인터페이스명 {  
    int blabla;  
    public void bla();  
}
- 컴파일러가 interface를 읽어 들이면서 public static final을 생략한 변수와 public abstract를 생략한 메소드()에 자동으로 붙여준다.
6. 인터페이스의 상속
- extends가 아니라 implements 키워드를 사용하여 상속한다.  
e.g. public class명 <b style="color: red;">implements</b> 인터페이스명 {  
}
- class 상속과 달리 다중 상속이 가능하다. 다만 class도 인터페이스는 다중으로 상속 받을 수 있다. 인터페이스까리도 다중 상속 가능하다.  
e.g. public class명 implements 인터페이스1, 인터페이스2 {  
}
- 인터페이스끼리 상속을 주고받을 때는 extends를 사용한다.  
e.g. interface 자식인터페이스 extends 부모1, 부모2 {  
}
- 인터페이스를 상속 받은 class에서 인터페이스의 추상메소드()를 일부만 구현하려면 class 자체를 추상class로 선언해야 한다.
7. 인터페이스도 인스턴스화를 통한 객체 생성이 불가능하다. 해당 인터페이스를 상속 받은 자식class를 객체로 만들어서 사용한다.

# 2. default 메소드()
1. 부모 인터페이스에 새로운 기능을 추가하려면 추상메소드()를 선언하고 자식class에서 구현해야 한다. 상속 받은 자식class가 많아질수록 구현해야 하는 코드도 증가한다.
2. 상기한 문제를 해결하기 위해서 JDK 1.8부터 default 메소드()를 통해 부모 인터페이스에만 메소드()를 선언하고 구현하도록 유도하고 있다.
3. default 메소드() 선언과 구현 방식
- 인터페이스 {  
    추상메소드1;  
    추상메소드2;

    (public) default 리턴타입 메소드명() {  
            인터페이스에서 구현부까지 구현한다  
    }  
}
- default 메소드()는 접근제어자를 생략할 시 public으로 설정된다.
- default 메소드()는 오버라이딩도 가능하다. 그러나 static 메소드()는 오버라이딩이 불가하며 선언된 인터페이스를 이용한 호출만 가능하다.

# 3. 인터페이스의 장단점
1. 인터페이스의 장점
- 다중 상속이 가능하다. 여러 개의 인터페이스를 상속 받아 구현하면 유연한 객체를 생성할 수 있다.
- 인터페이스를 구현한 클래스를 다른 프로젝트에서도 사용할 수 있기 때문에 코드의 재사용성이 높아진다.
- default 메소드()를 이용하여 새로운 기능을 추가하기 쉽다. 또는 인터페이스에는 메소드()를 선언만 해두고 구현체(상속 받은 class)에서 기능을 구현하면 되기 때문에 유지보수성도 높아진다.
- 인터페이스를 이용하면 다형성도 쉽게 구현할 수 있다. 부모 인터페이스 타입의 변수에 다양한 구현체를 대입하여 여러 가지 기능으로 사용할 수 있다.
2. 인터페이스의 단점
- 인터페이스는 추상화 레벨이 높기 때문에 설계하고 구현하는 데에 시간이 오래 걸린다. 목적과 용도를 정확하게 특정한 상태에서 설계와 구현을 진행하기 때문에 구조나 기능을 생각하는 데에 많은 시간을 투자해야 한다.
- 인터페이스에 선언되어 있는 추상메소드()를 구현체에서 모두 구현해야 한다. 구현체에서 필요없는 기능이어도 인터페이스에 선언되어 있으면 무조건 구현해야 되기 때문에 불필요한 코드가 작성된다.
- 상속의 깊이가 깊어질수록 구조와 설계 자체가 복잡해진다.